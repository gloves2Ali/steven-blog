#### 排序算法

+ selection sort
在你面前有3个苹果，每次你都挑最大的吃，就是选择排序。

例子
数组排序：我们需要进行n（组数的长度）次选择，每次选择的结果和第n位元素交换：
```javascript
int[] stu = [2,3,4,1];

// 2341选1，和2交换
int[] stu = [1,3,4,2];

// 342选2，和3交换
int[] stu = [1,2,4,3];

// 34选3，和4交换
int[] stu = [1,2,3,4];

// 4选4，和4交换
int[] stu = [1,2,3,4];
```

代码实现
```javascript
public static void sort(Comparable[] a) {
  int n = a.length;
  for (int i = 0; i < n; i++) {
    int min = i;
    for (int j = i+1; j < n; j++) {
      if (less(a[j], a[min])) min = j;
    }
    // 每次循环找到最小的值，交换到i位置
    exch(a, i, min);
  }
}
```
容易发现，选择排序每次的比较次数就是剩余的元素个数，交换次数就是数组长度

小结
总结选择排序的特点：
简单易学
慢（需要n的平方级别的比较次数）
即使数组有序，花费的时间仍然是不变的。

+ insertion sort
假设10,J,Q,A已经整理好的牌，如果要找到K的位置，只要从A的后面移动到K的后面即可，这就是插入排序的一部分。

举例
数组排序：永远保证当前元素左侧的所有元素是有序的，当进行到最后一个元素时，整个数组就是有序的。
```javascript
int[] stu = [2,4,3,1];

// 保证第一个元素是有序的：不动
int[] stu = [2,4,3,1];

// 保证前2个元素是有序的：不动
int[] stu = [2,4,3,1];

// 保证前3个元素有序：3和4交换
int[] stu = [2,3,4,1];

// 保证第4个元素有序，1先后和4，3，2交换
int[] stu = [1,2,3,4];
```
从第2，3步我们发现，插入排序只比较了比自己大的元素，而不是全面的所有元素。

代码实现
```javascript
public static void sort(Comparable[] a) {
  int n = a.length;
  for (int i = 1; i < n; i++) 
  {
    for (int j = i; j > 0 && less(a[j], a[j-1]); j--)
    {
       exch(a, j, j-1);
     }
   }
}
```
内层循环的less(a[j], a[j-1])判断正是上文得到的总结，也是插入排序比选择排序快的原因。

小结
总结插入排序的特点：

慢（虽然比选择排序快一些）
每次交换只能交换相邻的元素导致交换次数多。例子的最后一步可见：元素1必须和前面的所有元素交换才能到达自己的位置。
